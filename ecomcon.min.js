// ecomcon.js
// Douglas Crockford
// 2018-08-08
// Modified by Jonathan Reimer, 2020-11-19

const rx_crlf = /\n|\r\n?/;

const rx_ecomcon = /^\/\/([a-zA-Z0-9_]+)\u0020?(.*)$/;

//. Capturing groups:
//.  [1] The enabled comment tag
//.  [2] The rest of the line

const rx_tag = /^[a-zA-Z0-9_]+$/;

// Default output function
const write_line = function (line) {
    return line + "\n";
};

const remove_empty_lines = function (line) {
    return (line.length > 0);
};

const remove_multiple_blank_lines = function (line, index, source) {
    return ((line !== "\n") || (index === 0) || (source[index - 1] !== "\n"));
};

export default Object.freeze(function ecomcon(options = {}) {
    return function (source_string) {
        let tag = Object.create(null);

// deconstruct options - options may be an array
        const {
            tag_list = [],
            comments_array = [],
            on_tagged = write_line,
            on_untagged = write_line
        } = options;

// options must be an array or an object
        if (typeof options !== "object") {
            throw new Error("ecomcon: invalid tag list");
        }

// validate options as an array and convert to tag object
// this is the original behavior
        if (Array.isArray(options)) {
            options.forEach(
                function (string) {
                    if (!rx_tag.test(string)) {
                        throw new Error("ecomcon: " + string);
                    }
                    tag[string] = true;
                }
            );

// validate tag_list as an array and convert to tag object
        } else if (Array.isArray(tag_list)) {
            tag_list.forEach(
                function (string) {
                    if (!rx_tag.test(string)) {
                        throw new Error("ecomcon: " + string);
                    }
                    tag[string] = true;
                }
            );

// validate tag_list as an object
// property names are tags
// values can be either
//      -true, which will use the default on_tagged function
//      -a unary function to be applied to tagged lines
        } else {
            Object.values(tag_list).forEach(
                function (value) {
                    if ((value !== true) && (
                        (typeof value !== "function") || (value.length > 1)
                    )) {
                        throw new Error("ecomcon: invalid tag function");
                    }
                }
            );
            tag = tag_list;
        }

        if (!Array.isArray(comments_array)) {
            throw new Error("ecomcon: invalid comments list");
        }

// Add functionality described in original documentation
        return comments_array.map(
            function (line) {
                return "// " + write_line(line);
            }
        ).concat(source_string.split(rx_crlf).map(
            function (line) {
                const array = line.match(rx_ecomcon);

// If tag property is true, use global on_tagged function on the line
// If tag property is a function, use it on the line
                return (
                    (Array.isArray(array) && (tag[array[1]] !== undefined))
                    ? (
                        (tag[array[1]] === true)
                        ? on_tagged(array[2])
                        : tag[array[1]](array[2])
                    )
                    : on_untagged(line)
                );
            }
        ).filter(
            remove_empty_lines
        ).filter(
            remove_multiple_blank_lines
        )).join("");
    };
});

